---
title: "Population Graphs On Contigs I: Sampling Intensity & Topological Convergence"
description: |
  With the ever increasing use of sequencing in the analysis of both neutral and putatively adaptive genetic variance the ability to recover genetic covartiance becomes increasinly difficult as the density of information rich genetic markers incereases.  In this manuscript, we examine the extent to which population genetic structure, as measured through population graphs, is influenced by locus proximity.
author:
  - name: Rodney J. Dyer
    url: https://dyerlab.org
    affiliation: Center for Environmental Studies<br>Virginia Commonwealth University<br>&nbsp;
    affiliation_url: https://ces.vcu.edu
    orcid_id: 0000-0003-4707-3453
date: "`r Sys.Date()`"
bibliography: bibliography.bib
output: distill::distill_article
knit: (function(inputFile, encoding) { 
  rmarkdown::render(inputFile,
                    encoding=encoding,
                    output_file='docs/index.html') })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options( tidyverse.quiet = TRUE, 
         dplyr.summarise.inform = FALSE )

library( tidyverse )
theme_set( theme_minimal(base_size=14 ))

library( popgraph )
library( gstudio )
library( igraph )
```



Are there metrics that can be used to define topological and structural similarity in one or more population graphs?


Specifically, we test the following questions:  

1. How many SNP loci are necessary to gain a stable genetic covariance structure as measured through a population graph?

2. How do graph-theoretic properties change with genetic sampling effort as sample sizes tend towards topographic convergence?


3. Some other thing.




# Methods


## Graph Theoretic Definitions

A graph contains two sets of objects, *nodes* often representing sampling locales, populations, or regions, and *edges* which specify the relationships between individual nodes.  In population genetic studies, graphs are often defined based upon pair-wise genetic distances (Nei's Distance, $D_{ps}$, etc.) or estimates of structure (pairwise $F_{ST}$, cGD, etc).

For the purposes of this paper, genetic topologies will be created using conditional genetic distance (cGD) found within Population Graph [@Dyer2004,@Dyer2015]

## The Data

```{r}
load("data/df_snps.rda")
K <- nrow(df_snps)
df_snps$dist <- NA
df_snps$dist[2:K] = df_snps$Location[2:K] - df_snps$Location[1:(K-1)]
```


For this manuscript, single nucleotide polymorphisms (SNP) data from HGDP-CEPH for Chromosome 2 were used due to the relative density of variable markers.  These data consist of `r K` mapped variable nucleotide sites.  Distances between individual snps ranged from `r min(df_snps$dist, na.rm=TRUE)`bp - `r format(max(df_snps$dist, na.rm=TRUE),digits=2, scientific=TRUE)`bp (the largest spanning the centromere), whose distribution of inter-snp distances are arranged as shown in Figure \@ref(fig:snp-distance). 

```{r snp-distance, fig.cap="The distribution of nearest neighbor distances for individual SNPs along Chromosome 2"}
df_snps %>%
  filter( !is.na(dist) ) %>%
  ggplot( aes(log(dist,base = 10)  ) ) + 
  geom_density()  + 
  xlab(expression(log[10](Nucleotide~Distance))) +
  ylab("Frequency")
```













## Topological Similarity


### Isomorphism in Graph Structure

As a first pass, one can consider the  similarity of two graphs.  For example, consider the graphs $G$ and $H$, both of which have identical node sets (e.g., the two graphs have the same cardinality in that $V(G) = V(H)$).  For most purposes here, we will only be considering comparisons of graphs that have the identical set of nodes as we are looking at population-level genetic covariance among the same set of populations only with different sets of genetic markers.  

In this context, any pair of population graphs are said to be *graph-level isomorphic* if and only if the exact same set of edges in popgraph $G$ are present in other popgraph $H$.  For this paper, I will refer to this a *structural congruence* to designate that it is the set of similar edges in the two networks that are the focus of the question.   


In addition to structural congruence, population graphs may be similar because they have a similar configuration of the overall distances between sampling locals, independent of the sequence of edges through which they traverse.  This is the most commonly used approach as we typically estimate the measure of distance between sites from the genetic data and relate that to some measure of separation caused by space, ecology, vicariance, etc.  The distinction here is that the actual path, and by extension the individual connections between sampling locales, are not the focus of the question, only the cumulative distance between nodes.   


*Structural Congruence* 

For questions regarding the arrangement of connections between specific nodes in the topology.  The likelihood that two graphs with isomorphic node sets (say of size $K$), $A$ and $B$, have $m$ edges in common can be determined combinatorially with the following definitions.  Let $m_A$ be the number of edges in $A$, $m_B$ be the number of edges in graph $B$, and $m_C$ be the number of edges in the congruence topology derived from both $A$ and $B$. The maximum number of potential edges (and hence the ceiling for $m_C$) is $m_{max} = K * (K-1) / 2$.  


```{r warnings=FALSE}

## Pass this function the 
getCongruences <- function( files ) { 
  # Make response matrix to put structural (i<j) and distance congruence (i>j) values
  A <- matrix(NA,nrow=100,ncol=100)
  cat("getCongruences: ")
  for( i in 1:length(files) ) { 
    load( files[i] )
    g1 <- g 
    cat(".")
    for( j in 1:length(files) ) { 
      g <- NULL 
      load(files[j])
      
      if( i < j ) { 
        A[i,j] <- length(E(congruence_topology(g,g1)))
      } else if( i > j ) { 
        A[i,j] <- test_congruence(g,g1)$estimate
      }
    }
  }
  cat("\n")
  ret <- list( "Congruence" = A[upper.tri(A)],
               "Distance" = A[lower.tri(A)])
  
}

NUMLOCI <- c(seq(10,100,by=10), seq(150,500,by=25) )

if(!file.exists("data/df_congruence.rda") ) {
  df_congruence <- data.frame( NumLoci = NA, 
                               Congruence = NA, 
                               Distance = NA )
  print("Running Congruences")
  for( numLoci in NUMLOCI ) { 
    cat("Congruences derived for", numLoci,"\n")
    pattern <- paste("graph_",numLoci,"_",sep="")
    cong <- getCongruences( files = list.files("data/random_convergence", 
                                               pattern=pattern, 
                                               full.names = TRUE))
    df_congruence <- rbind( df_congruence,
                            data.frame( NumLoci = numLoci,
                                        Congruence = cong$Congruence, 
                                        Distance = cong$Distance ) )
  }
  df_congruence %>%
    filter( !is.na(NumLoci)) -> df_congruence
            
  save(df_congruence, file="data/df_congruence.rda")

} else { 
    load("data/df_congruence.rda")
}

```




```{r}
df_congruence %>%
  group_by( NumLoci ) %>%
  summarise( Var = var(Congruence)) -> varCong


varCong %>%
  ggplot( aes(NumLoci, Var) ) + 
  geom_point() + 
  stat_smooth(se=FALSE,
              method = "loess",
              formula = y ~ x,
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") + 
  ylab("Variance In Structural Congruence")
```




*Distance Congruence*

For questions and hypotheses regarding the relative genetic distances between locales as is common in studies of isolation by distance, resistance, and ecology.

```{r, warning=FALSE}
df_congruence %>%
  group_by( NumLoci ) %>%
  summarise( Var = var(Distance)) -> varDist

varDist %>%
  filter( NumLoci <= 100) %>%
  ggplot( aes(NumLoci, Var) ) + 
  geom_point() + 
  stat_smooth(se=FALSE,
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") + 
  ylab("Variance In Distance Congruence")
```



```{r}
varDist %>%
  ggplot( aes(NumLoci, Var) ) + 
  geom_point() + 
  stat_smooth(se=FALSE,
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") + 
  ylab("Variance In Distance Congruence")
```




### Window Sampling



```{r}

if(!file.exists("data/df_seqcongruence.rda") ) {
  df_seqcongruence <- data.frame( NumLoci = NA, 
                               Congruence = NA, 
                               Distance = NA )
  print("Running Sequential Congruences")
  for( numLoci in NUMLOCI  ) { 
    cat("Congruences derived for", numLoci,"\n")
    pattern <- paste("graph_",numLoci,"_",sep="")
    cong <- getCongruences( files = list.files("data/sequential_convergence", 
                                               pattern=pattern, 
                                               full.names = TRUE))
    df_seqcongruence <- rbind( df_seqcongruence,
                            data.frame( NumLoci = numLoci,
                                        Congruence = cong$Congruence, 
                                        Distance = cong$Distance ) )
  }
  df_seqcongruence %>%
    filter( !is.na(NumLoci)) -> df_seqcongruence
            
  save(df_seqcongruence, file="data/df_seqcongruence.rda")

} else { 
    load("data/df_seqcongruence.rda")
}

```



*Structural Congruence*


```{r}
df_seqcongruence %>%
  group_by(NumLoci) %>%
  summarise(`Structural Congruence` = var( Congruence ) ) %>%
  ggplot( aes(NumLoci, `Structural Congruence`) ) + 
  geom_point() +    
  stat_smooth(se=FALSE,
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") + 
  ylab("Variance In Structural Congruence")
```



*Distance Congruence*



```{r}
df_seqcongruence %>%
  filter( NumLoci <= 100) %>%
  group_by(NumLoci) %>%
  summarise(`Distance Congruence` = var( Distance, na.rm=TRUE) ) %>%
  ggplot( aes(NumLoci, `Distance Congruence`) ) + 
  geom_point() +  
  stat_smooth(se=FALSE,
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") + 
  ylab("Variance In Distance Congruence")
```


```{r}
df_seqcongruence %>%
  group_by(NumLoci) %>%
  summarise(`Distance Congruence` = var( Distance, na.rm=TRUE) ) %>%
  ggplot( aes(NumLoci, `Distance Congruence`) ) + 
  geom_point() +  
  stat_smooth(se=FALSE,
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") + 
  ylab("Variance In Distance Congruence")
```









## Disconnected Subgraphs

```{r}
df_snps$graphs <- 0
df_snps$disconnected <- 0

for( file in list.files("data/random_convergence", pattern = "graph_100_*", full.names = TRUE)  ) { 
  g <- NULL
  load(file) 
  snps <- strsplit(igraph::graph.attributes(g)$SNPs, split=",")[[1]]
  
  df_snps$graphs[ df_snps$Name %in% snps ]  <- df_snps$graphs[ df_snps$Name %in% snps ] + 1.0 
  if( igraph::components(g)$no > 1 ) { 
    df_snps$disconnected[ df_snps$Name %in% snps]   <- df_snps$disconnected[ df_snps$Name %in% snps]   + 1.0 
  }
}

df_snps %>%
  filter( graphs > 0 ) %>% 
  group_by(disconnected) %>%
  summarize( N = n() ) %>%
  ggplot( aes(disconnected,N) )  + 
  geom_col() + 
  xlab("Number of Disconnected Graphs") + 
  ylab("Frequency")
```



## Sensitivity Analysis

How do we determine if some subset of loci in a population graph are having differential impact on the overall structure?







### Locus Sensitivity


\[
det(A-\lambda I) = 0 
\]



```{r}




```



### Locale Sensitivity













# Discussion



1. Adding more data does not tend towards a concensus graph because of unequal 











# Acknowledgements







