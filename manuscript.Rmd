---
title: "Population Graphs On Contigs I: Sampling Intensity & Topological Convergence"
description: |
  With the ever increasing use of sequencing in the analysis of both neutral and putatively adaptive genetic variance the ability to recover genetic covartiance becomes increasinly difficult as the density of information rich genetic markers incereases.  In this manuscript, we examine the extent to which population genetic structure, as measured through population graphs, is influenced by locus proximity.
author:
  - name: Rodney J. Dyer
    url: https://dyerlab.org
    affiliation: Center for Environmental Studies<br>Virginia Commonwealth University<br>&nbsp;
    affiliation_url: https://ces.vcu.edu
    orcid_id: 0000-0003-4707-3453
date: "`r Sys.Date()`"
bibliography: bibliography.bib
output: distill::distill_article
knit: (function(inputFile, encoding) { 
  rmarkdown::render(inputFile,
                    encoding=encoding,
                    output_file='docs/index.html') })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options( tidyverse.quiet = TRUE, 
         dplyr.summarise.inform = FALSE )

library( tidyverse )
theme_set( theme_minimal(base_size=14 ))

library( popgraph )
library( gstudio )
library( igraph )
```



Are there metrics that can be used to define topological and structural similarity in one or more population graphs?


Specifically, we test the following questions:  

1. How many SNP loci are necessary to gain a stable genetic covariance structure as measured through a population graph?

2. How do graph-theoretic properties change with genetic sampling effort as sample sizes tend towards topographic convergence?


3. Some other thing.




# Methods


## Graph Theoretic Definitions

A graph contains two sets of objects, *nodes* often representing sampling locales, populations, or regions, and *edges* which specify the relationships between individual nodes.  In population genetic studies, graphs are often defined based upon pair-wise genetic distances (Nei's Distance, $D_{ps}$, etc.) or estimates of structure (pairwise $F_{ST}$, cGD, etc).

For the purposes of this paper, genetic topologies will be created using conditional genetic distance (cGD) found within Population Graph [@Dyer2004,@Dyer2015]

## The Data

```{r}
load("data/df_snps.rda")
K <- nrow(df_snps)
df_snps$dist <- NA
df_snps$dist[2:K] = df_snps$Location[2:K] - df_snps$Location[1:(K-1)]
```


For this manuscript, single nucleotide polymorphisms (SNP) data from HGDP-CEPH for Chromosome 2 were used due to the relative density of variable markers.  These data consist of `r K` mapped variable nucleotide sites.  Distances between individual snps ranged from `r min(df_snps$dist, na.rm=TRUE)`bp - `r format(max(df_snps$dist, na.rm=TRUE),digits=2, scientific=TRUE)`bp (the largest spanning the centromere), whose distribution of inter-snp distances are arranged as shown in Figure \@ref(fig:snp-distance). 

```{r snp-distance, fig.cap="The distribution of nearest neighbor distances for individual SNPs along Chromosome 2"}
df_snps %>%
  filter( !is.na(dist) ) %>%
  ggplot( aes(log(dist,base = 10)  ) ) + 
  geom_density()  + 
  xlab(expression(log[10](Nucleotide~Distance))) +
  ylab("Frequency")
```



## Disconnected Subgraphs

```{r}
df_snps$graphs <- 0
df_snps$disconnected <- 0

for( file in list.files("data/sequential_convergence", full.names = TRUE)  ) { 
  g <- NULL
  load(file) 
  snps <- strsplit(igraph::graph.attributes(g)$SNPs, split=",")[[1]]
  
  df_snps$graphs[ df_snps$Name %in% snps ]  <- df_snps$graphs[ df_snps$Name %in% snps ] + 1.0 
  if( igraph::components(g)$no > 1 ) { 
    df_snps$disconnected[ df_snps$Name %in% snps]   <- df_snps$disconnected[ df_snps$Name %in% snps]   + 1.0 
  }
}

range(df_snps$Location)

df_snps %>%
  group_by(disconnected) %>%
  summarize( N = n() )

```










## Topological Similarity


### Isomorphism in Graph Structure

As a first pass, one can consider the structural similarity of two graphs.  For example, consider the graphs $G$ and $H$, both of which have identical node sets (e.g., the two graphs have the same cardinality in that $V(G) = V(H)$).  For most purposes here, we will only be considering comparisons of graphs that have the identical set of nodes as we are looking at population-level genetic covariance among the same set of populations only with different sets of genetic markers.  

In this context, any pair of population graphs are said to be *graph-level isomorphic* if and only if the exact same set of edges in popgraph $G$ are present in other popgraph $H$.  Another way of saying this is that a derived *congruence topology*, which is defined as the set of edges that are found in both graphs, has the same number of edges as the parental graphs.  



*Structural Congruence* 

For questions regarding the arrangement of connections between specific nodes in the topology.  The likelihood that two graphs with isomorphic node sets (say of size $K$), $A$ and $B$, have $m$ edges in common can be determined combinatorialy with the following definitions.  Let $m_A$ be the number of edges in $A$, $m_B$ be the number of edges in graph $B$, and $m_C$ be the number of edges in the congruence topology derived from both $A$ and $B$. The maximum number of potential edges (and hence the ceiling for $m_C$) is $m_{max} = K * (K-1) / 2$.  




```{r warnings=FALSE}

## Pass this function the 
getCongruences <- function( files ) { 
  # Make response matrix to put structural (i<j) and distance congruence (i>j) values
  A <- matrix(NA,nrow=100,ncol=100)
  cat("getCongruences: ")
  for( i in 1:length(files) ) { 
    load( files[i] )
    g1 <- g 
    cat(".")
    for( j in 1:length(files) ) { 
      g <- NULL 
      load(files[j])
      
      if( i < j ) { 
        A[i,j] <- length(E(congruence_topology(g,g1)))
      } else if( i > j ) { 
        A[i,j] <- test_congruence(g,g1)$estimate
      }
    }
  }
  cat("\n")
  ret <- list( "Congruence" = A[upper.tri(A)],
               "Distance" = A[lower.tri(A)])
  
}


if(!file.exists("data/df_congruence.rda") ) {
  df_congruence <- data.frame( NumLoci = NA, 
                               Congruence = NA, 
                               Distance = NA )
  print("Running Congruences")
  for( numLoci in seq(10,100,by=10) ) { 
    cat("Congruences derived for", numLoci,"\n")
    pattern <- paste("graph_",numLoci,"_",sep="")
    cong <- getCongruences( files = list.files("data/random_convergence", 
                                               pattern=pattern, 
                                               full.names = TRUE))
    df_congruence <- rbind( df_congruence,
                            data.frame( NumLoci = numLoci,
                                        Congruence = cong$Congruence, 
                                        Distance = cong$Distance ) )
  }
  df_congruence %>%
    filter( !is.na(NumLoci)) -> df_congruence
            
  save(df_congruence, file="data/df_congruence.rda")

} else { 
    load("data/df_congruence.rda")
}






```




```{r}
df_congruence %>%
  group_by( NumLoci ) %>%
  summarise( Var = mean(Congruence)) -> varCong


varCong %>%
  ggplot( aes(NumLoci, Var) ) + 
  geom_point() + 
  stat_smooth(se=FALSE, 
              method="nls", 
              formula = y ~ SSasymp(x,Asym,R0,lrc), 
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") + 
  ylab("Structural Congruence")
```




*Distance Congruence*

For questions and hypotheses regarding the relative genetic distnaces between locales as is common in studies of isolation by distance, resistance, and ecology.

```{r}
df_congruence %>%
  group_by( NumLoci ) %>%
  summarise( Var = mean(Distance)) -> varDist



varDist %>%
  ggplot( aes(NumLoci, Var) ) + 
  geom_point() + 
  stat_smooth(se=FALSE, 
              method="nls", 
              formula = y ~ SSasymp(x,Asym,R0,lrc), 
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") + 
  ylab("Distance Congruence")
```




### Window Sampling



```{r}

if(!file.exists("data/df_seqcongruence.rda") ) {
  df_seqcongruence <- data.frame( NumLoci = NA, 
                               Congruence = NA, 
                               Distance = NA )
  print("Running Sequential Congruences")
  for( numLoci in seq(10,100,by=10) ) { 
    cat("Congruences derived for", numLoci,"\n")
    pattern <- paste("graph_",numLoci,"_",sep="")
    cong <- getCongruences( files = list.files("data/sequential_convergence", 
                                               pattern=pattern, 
                                               full.names = TRUE))
    df_seqcongruence <- rbind( df_congruence,
                            data.frame( NumLoci = numLoci,
                                        Congruence = cong$Congruence, 
                                        Distance = cong$Distance ) )
  }
  df_seqcongruence %>%
    filter( !is.na(NumLoci)) -> df_seqcongruence
            
  save(df_congruence, file="data/df_seqcongruence.rda")

} else { 
    load("data/df_seqcongruence.rda")
}

```



*Structural Congruence*


```{r}
df_seqcongruence %>%
  group_by(NumLoci) %>%
  summarise(`Structural Congruence` = mean( Congruence ) ) %>%
  ggplot( aes(NumLoci, `Structural Congruence`) ) + 
  geom_point() +  
  stat_smooth(se=FALSE, 
              method="nls", 
              formula = y ~ SSasymp(x,Asym,R0,lrc), 
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") 
```



*Distance Congruence*



```{r}
df_seqcongruence %>%
  group_by(NumLoci) %>%
  summarise(`Distance Congruence` = mean( Distance ) ) %>%
  ggplot( aes(NumLoci, `Distance Congruence`) ) + 
  geom_point() +  
  stat_smooth(se=FALSE, 
              method="nls", 
              formula = y ~ SSasymp(x,Asym,R0,lrc), 
              linetype=2,
              size=1) + 
  xlab("Number of SNP Loci") 
```



### Characterisitics of Network Structure


Network similarity may be partitioned into features based upon the *node*, on the *edge*, or on the overall construction of the network itself.  For comparison purposes, we will 

*Node Centric Features*  

- *Degree* The number of edges connected to a particular node in the network.    
- *Node Betweenness* A measure of the relative number of the shortest paths in the network that contain each node.
- *Node Closeness* The relative distance of a node to all other nodes in the network. 


*Edge Centric Features*

- *Edge Betweenness* The relative number of shortest paths in the entire network that contain each edge.
- *Distance Congruence* The r
- *Structural Congruence* 

*Graph Features*

- *Diameter* The distance through the graph connecting the two most distant nodes.
- *Slope<sub>Degree</sub>* - 

Feature                | Description    
-----------------------|------------------------------   
Degree                 | The number of edges connected to a node    
Node Betweenness       | The number of shortest paths in the network that traverse each node.
Node Closeness         | The relative closeness of a node to all other nodes in the network.
cGD                    | The length of the shortest path connecting nodes in the Population Graph   
Edge Betweenness       | The number of shortest paths in the network that traverse each edge    
Slope<sub>Degree</sub> | The slope of the degree distribution describing the
Diameter               |   
 






## Assympototic Stability






*Random Markers*





```{r}
df_random <- data.frame( fname = list.files("data/random_convergence",
                                            full.names=TRUE)  )
df_random$NumLoci <- as.numeric( matrix( unlist( strsplit( df_random$fname, "_")),
                                         ncol=4, 
                                         byrow=TRUE)[,3])
df_random$Degree <- NA
df_random$Diameter <- NA
df_random$NodeCloseness <- NA
df_random$NodeBetweenness <- NA
df_random$EdgeWt <- NA
df_random$cGD <- NA

for( i in 1:nrow(df_random) ) { 
  g <- NULL
  load( df_random$fname[i] )
  c <- to_matrix(g, mode="shortest path") 
  df_random$Degree[i] <- mean(degree(g), na.rm=TRUE )
  df_random$Diameter[i] <- max( c, na.rm=TRUE )
  df_random$NodeCloseness[i] <- mean(closeness(g), na.rm=TRUE )
  df_random$NodeBetweenness[i] <- mean( betweenness(g), na.rm=TRUE )
  df_random$EdgeWt[i] <- mean( to_matrix(g,mode="edge weight"), na.rm=TRUE )
  cgd <- c[lower.tri(c)] 
  df_random$cGD[i] <- mean(cgd[ !is.infinite(cgd) ], na.rm=TRUE)
}

df_random$Diameter[is.infinite(df_random$Diameter)] <- NA


df_random %>%
  group_by( NumLoci ) %>%
  summarise( Degree = mean(Degree),
             sdDegree = sd(Degree),
             Diameter = mean(Diameter, na.rm=TRUE),
             sdDiameter = sd(Diameter),
             NodeCloseness = mean(NodeCloseness, na.rm=TRUE),
             sdNodeCloseNess = sd(NodeCloseness),
             NodeBetweenness = mean( NodeBetweenness, na.rm=TRUE), 
             sdNodeBetweeenness = sd( NodeBetweenness ),
             EdgeWt = mean(EdgeWt, na.rm=TRUE),
             sdEdgeWt = sd(EdgeWt ),
             cGD = mean( cGD , na.rm=TRUE),
             sdcGD = sd(cGD) ) -> rand_summary


df_random %>%
  mutate(Loci=as.factor(NumLoci) ) %>%
  ggplot( aes(Loci, cGD) ) + 
  geom_boxplot( notch=TRUE )


```


*Sequential Markers*

Asymptotic convergence on topology from sequentialSNP's.






## Sampling Intensity

















# Acknowledgements







